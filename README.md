# AI Problem-Solving Facilitator

An interactive web application that leverages **Google Gemini** and **consulting-grade frameworks** to guide individuals or teams through a structured problem-solving journey. Tailor-made for small & medium-sized Italian service companies (PMI), the app combines AI insights, proven playbooks and collaboration utilities.

## Table of Contents
- [AI Problem-Solving Facilitator](#ai-problem-solving-facilitator)
  - [Table of Contents](#table-of-contents)
  - [Key Features](#key-features)
  - [Tech Stack](#tech-stack)
  - [Getting Started](#getting-started)
    - [Prerequisites](#prerequisites)
    - [Installation](#installation)
    - [Environment Variables](#environment-variables)
    - [Run Locally](#run-locally)
    - [Build for Production](#build-for-production)
  - [Supabase Setup](#supabase-setup)
  - [Playbooks Library](#playbooks-library)
  - [Project Structure](#project-structure)
  - [Roadmap](#roadmap)
  - [Contributing](#contributing)
    - [Code Style](#code-style)
  - [License](#license)

---

## Key Features
* **AI-Guided Analysis** – Google Gemini suggests frameworks, strategy and final goals based on problem & context provided.
* **Framework Walk-Through** – Step-by-step guidance, key questions and templates for each methodology.
* **Pre-built Playbooks** – Ready-to-use consulting pathways (Cost Reduction, Digital Transformation) with KPIs, risks and stakeholder maps.
* **Stakeholder Matrix & Risk Register** – Visual tools to manage influence/interest and implementation risks.
* **Implementation Roadmap** – Phased plan with activities, deliverables & KPI tracking.
* **Sessions Persistence** – All sessions stored securely on Supabase (PostgreSQL) instead of localStorage.
* **Modern UI/UX** – React + Tailwind CSS, light theme, icons and subtle animations for a crisp experience.

## Tech Stack
| Layer                | Technology                               |
|----------------------|-------------------------------------------|
| Front-end            | React 18, TypeScript, Vite               |
| Styling              | Tailwind CSS                             |
| Icons                | Heroicons (custom wrapper components)    |
| State / Data         | React Hooks, Context (local)             |
| Back-end-as-a-Service| Supabase (PostgreSQL + Storage + RLS)     |
| AI Provider          | Google Gemini API                        |

## Getting Started

### Prerequisites
* **Node.js ≥ 18**
* A **Google Gemini API key**
* A **Supabase project** with anon & service keys

### Installation
```bash
# 1. Clone the repository
$ git clone https://github.com/krea424/ai-problem-solving-facilitator.git
$ cd ai-problem-solving-facilitator

# 2. Install dependencies
$ npm install
```

### Environment Variables
Create a file named `.env.local` in the project root:
```ini
VITE_GEMINI_API_KEY=your_gemini_key_here
VITE_SUPABASE_URL=https://xyzcompany.supabase.co
VITE_SUPABASE_ANON_KEY=public_anon_key
```

### Run Locally
```bash
# Start Vite dev server (http://localhost:5173)
$ npm run dev
```

### Build for Production
```bash
$ npm run build
$ npm run preview   # optional local preview
```

## Supabase Setup
1. Create a **table** named `sessions`:
   ```sql
   create table public.sessions (
     id          bigint generated by default as identity primary key,
     created_at  timestamptz default now(),
     name        text not null,
     content     jsonb
   );
   ```
2. Enable **Row-Level Security** and allow read/write for anon users (or tighten as required):
   ```sql
   alter table public.sessions enable row level security;
   create policy "Public CRUD" on public.sessions
   for all using ( true ) with check ( true );
   ```
3. Copy the **Anon public key** and project URL into `.env.local` as shown above.

## Playbooks Library
The file `data/playbooks.ts` hosts consulting playbooks. Each `Playbook` is typed and contains:
* **Objective** – clear business value target.
* **Framework chain** – cost tree, ABC, Lean Six Sigma etc.
* **Implementation Plan** – phases, activities, stakeholders, risks.
* **KPIs** – metrics & targets to monitor.

Feel free to add your own by following the interface in `types.ts`.

## Project Structure
```
├── components/       # Reusable UI pieces (Card, Loader, Icons, …)
│   ├── PlaybooksPanel.tsx
│   ├── FrameworkVisualizer.tsx
│   ├── StakeholderMatrix.tsx
│   └── ImplementationRoadmap.tsx
├── data/             # Static JSON/TS data (playbooks)
├── services/         # API wrappers for Gemini & Supabase
├── types.ts          # Global TypeScript type definitions
├── App.tsx           # Main application shell & routing
└── …
```

## Roadmap
- [ ] Add **team collaboration** (live cursor, comments)
- [ ] Export deliverables to **PDF / PowerPoint** templates
- [ ] Integrate with **Jira / Asana** to create tasks
- [ ] Multi-language UI (i18n) starting with IT ↔ EN
- [ ] Offline PWA support

## Contributing
Pull Requests are welcome! Please follow these steps:
1. Fork the repo & create your feature branch: `git checkout -b feat/awesome-feature`
2. Commit with Conventional Commits style: `git commit -m "feat: add X"`
3. Push to your fork: `git push origin feat/awesome-feature`
4. Open a PR and describe your change.

### Code Style
* **ESLint + Prettier** run on pre-commit (config coming soon)
* Keep components small & typed (`.tsx`).

## License
MIT © 2025 krea424

Ecco cosa fa – passo per passo – il workflow che abbiamo salvato in  
`.github/workflows/deploy.yml`:

```yaml
name: Deploy to GitHub Pages

on:
  push:
    branches: [main]          # parte a ogni push su main
  workflow_dispatch:          # oppure avvio manuale

jobs:
  build:
    runs-on: ubuntu-latest    # usa il runner GitHub standard
    steps:
      - uses: actions/checkout@v4      # 1. clona il repo
      - uses: actions/setup-node@v3    # 2. installa Node 18 e abilita cache npm
        with:
          node-version: 18
          cache: 'npm'
      - run: npm ci                    # 3. installa dipendenze
      - run: npm run build             # 4. esegue il build Vite (output in dist/)
      - uses: actions/upload-pages-artifact@v2   # 5. carica dist/ come artefatto
        with:
          path: './dist'
      - uses: actions/configure-pages@v2         # 6. configura Pages

  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - id: deployment
        uses: actions/deploy-pages@v2   # 7. pubblica l’artefatto su GitHub Pages
```

Comandi chiave eseguiti:

1. `npm ci` – installazione pacchetti (più veloce di `npm install` in CI).  
2. `npm run build` – avvia Vite per produrre `/dist`.  
3. L’artefatto viene caricato e poi distribuito dal passo `deploy`.

Perché ancora non vedi il workflow in esecuzione:

1. **Actions tab** – verifica se compaiono run falliti o in coda.  
2. Se non c’è alcun run, fai un commit “vuoto” così:

```bash
<code_block_to_apply_changes_from>
```

3. Attendi ~1-2 minuti: il nuovo run dovrebbe apparire (job **build** ► **deploy**).  
4. Quando è verde, in Settings → Pages apparirà l’URL pubblico.

Non è necessario configurare self-hosted runners: i nostri job usano quelli GitHub (`runs-on: ubuntu-latest`).
